use std::{thread::sleep, time::Duration};

use serenity::all::{
    CommandInteraction, CommandOptionType, Context, CreateCommand, CreateCommandOption,
    ResolvedOption, ResolvedValue,
};

pub fn scheduled_messages_run(command: &CommandInteraction, ctx: &Context) -> String {
    let options = command.data.options();
    if let Some(ResolvedOption {
        value: ResolvedValue::String(message),
        ..
    }) = options.first().cloned()
    {
        if let Some(ResolvedOption {
            value: ResolvedValue::Number(sleep_duration),
            ..
        }) = options.get(1).cloned()
        {
            let ctx = ctx.clone();
            let channel_id = command.channel_id;
            let sleep_duration = sleep_duration.clone();

            tokio::spawn(async move {
                sleep(Duration::from_secs(sleep_duration as u64));
                channel_id
                    .say(&ctx.http, message.to_string())
                    .await
                    .unwrap()
            });
            "fff".to_string()
        } else {
            unreachable!()
        }
    } else {
        unreachable!()
    }
}

pub fn scheduled_messages_register() -> CreateCommand {
    CreateCommand::new("schedule")
        .description("schedule a message")
        .add_option(
            CreateCommandOption::new(
                CommandOptionType::String,
                "message_text",
                "the text of the scheduled message",
            )
            .required(true),
        )
        .add_option(CreateCommandOption::new(
            CommandOptionType::Number,
            "send in",
            "in seconds",
        ))
}
